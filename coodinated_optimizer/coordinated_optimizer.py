from abc import abstractmethod
from typing import (
    Iterable,
    Optional,
    Tuple,
    )


class CoordinatedOptimizer:
    
    @abstractmethod
    def ask(self, num: Optional[int] = None) -> [any]:
        """
        :param num: the number of candidate messages to return. If undefined, the optimizer chooses how many.
        :return: a list of candidate messages generated by the optimizer
        """
        pass
    
    @abstractmethod
    def expand(self, candidate_message: any) -> any:
        """
        Expands a candidate_message into a candidate
        :param candidate_message: a candidate message generated by ask() or best()
        :return: a candidate to evaluate
        """
        pass
    
    def tell_messages(self, evaluations: Iterable[Tuple[float, any]]) -> None:
        """
        Updates the optimizer using candidate messages and their evaluation results
        :param evaluations:
        :return:
        """
        return self.tell(((evaluation[0], self.expand(evaluation[1])) for evaluation in evaluations))
    
    @abstractmethod
    def tell(self, evaluations: Iterable[Tuple[float, any]]) -> None:
        """
        Updates the optimizer using candidates and their evaluation results
        :param evaluations:
        :param debug:
        :return:
        """
        pass
    
    @abstractmethod
    def best(self) -> any:
        """
        :return: candidate message that corresponds to the current best solution
        """
        pass
    
    def best_candidate(self) -> any:
        """
        :return: current best candidate
        """
        return self.expand(self.best())
    
    def status(self) -> dict:
        """
        :return: any status information
        """
        return {}
